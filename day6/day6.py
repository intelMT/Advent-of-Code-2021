example = """3,4,3,1,2"""

import numpy as np
import time
from collections import Counter

class lanternfish:
    def __init__(self) -> None:
        self.school = list()
        self.counter = dict()
        for x in range(9):
            self.counter[x] = 0 

    # List/array approach - Very slow, impossible for computation of long days
    def count(self, n_days : int)-> int:
        for _ in range(n_days):
            y = np.array(self.school, dtype=np.int8)
            y -= 1
            num_newborn = sum(y == -1)
            y = np.append(y, np.array([8 for _ in range(num_newborn)], dtype=np.int8))
            self.school = np.where(y==-1, 6, y)
             
        return len(self.school)

    # 
    def count_with_dict(self, n_days: int) -> int:

        for fish in self.school:
            self.counter[fish] += 1
        
        # Assuming no fish has 0 as their initial days to spawn
        n_zeros = 0

        for i in range(n_days):
            # Counting the decrease of days for each fish by shifting the dictionary  
            for i in range(0,8):
                self.counter[i] = self.counter[i+1]

            # Each 0 turns into 6 and 8 corresponding to a new fish            
            self.counter[6] += n_zeros  # There could be other 6's because of newborns
            self.counter[8] = n_zeros
            # number of fishes to be generated next day
            n_zeros = self.counter[0] 
            

        return sum(self.counter.values())

    # Recursive approach - Not good
    def count_recursive(self, n_days: int)-> int:
        counter = Counter(self.school)
        total = 0
        # Counting based on the fact that each column value produces the same results.
        for key, val in counter.items():
            total += val*self.count_col(key, n_days)
        
        return total + len(self.school)
    
    # look for how many fish can be generated by an old or new fish
    def count_col(self, k:int, n_days: int):
        s = 0
        if k > n_days-1:    # can generate new fish till the day before last day
            return 0
        else:   
            for i in range(k, n_days, 7):
                s += self.gen_new(i+1,n_days)
            return s 
    # Generate new fish
    def gen_new(self, day: int, n_days:int):
        if day > n_days - 9: # A new fish can only generate another new fish if more than 9 days left.
            return 1
        else:
            return 1 + self.gen_new(day+9, n_days) + self.count_col(day+15, n_days)

    def parse(self, data: str) -> list:
        self.school = [int(x) for x in data.split(',')]
        
    def reset(self):
        self.school = list()
        self.counter = dict()
        for x in range(9):
            self.counter[x] = 0

toydata = lanternfish()
toydata.parse(example)

assert toydata.count_with_dict(18) == 26
assert toydata.count_recursive(18) == 26
assert toydata.count(18) == 26

toydata.reset()
toydata.parse(example)
assert toydata.count_with_dict(80) == 5934
assert toydata.count_recursive(80) == 5934
assert toydata.count(80) == 5934

# Part-2
toydata.reset()
toydata.parse(example)
assert toydata.count_with_dict(256) == 26984457539

if __name__ == '__main__':
    with open('d6.txt') as f:
        content = f.read()

    lfschool = lanternfish()
    lfschool.parse(content)
    tic = time.perf_counter()
    result = lfschool.count(80) # SLOWEST
    toc = time.perf_counter()
    print (f"List Result: {result}")
    print(f"List approach finished in {toc - tic:0.3f} seconds")

    lfschool.reset()
    lfschool.parse(content)
    tic = time.perf_counter()
    result = lfschool.count_recursive(80)
    toc = time.perf_counter()
    print (f"Recursive Result: {result}") # SLOW FOR COMPUTATION WITH LONG DAYS
    print(f"Recursive approach finished in {1000*(toc - tic):0.3f} miliseconds")
    
    lfschool.reset()
    lfschool.parse(content)
    tic = time.perf_counter()
    result = lfschool.count_with_dict(80) # FASTEST
    toc = time.perf_counter()
    print (f"Dictionary Result: {result}")
    print(f"Dictionary-(only counting) approach finished in {1000*(toc - tic):0.3f} miliseconds")
    
    lfschool.reset()
    lfschool.parse(content)
    tic = time.perf_counter()
    result = lfschool.count_with_dict(256) # Only possible with the dictionary approach.
    toc = time.perf_counter()
    print (f"Part-2 Result: {result} \nFinished in {1000*(toc - tic):0.3f} miliseconds")